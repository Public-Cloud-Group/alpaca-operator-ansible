#
# Description:
#   This GitHub Actions workflow provides comprehensive CI/CD for the pcg.alpaca_operator Ansible Collection.
#
#   The workflow consists of five main jobs:
#
#   1. CHANGELOG: Generates changelog from fragments (only on main branch)
#      - Checks for changelog fragments
#      - Merges fragments into changelog.yaml
#      - Generates CHANGELOG.rst
#      - Commits and pushes changes
#
#   2. TEST: Matrix testing across Python and Ansible version combinations
#      - Builds the Ansible collection using ansible-galaxy
#      - Installs the collection and runs sanity tests with ansible-test
#      - Classifies results as tested, failed, or unsupported
#      - Uploads individual test results as artifacts
#
#   3. SUMMARIZE: Aggregates test results and updates documentation
#      - Downloads all test artifacts and combines results
#      - Generates a comprehensive support matrix
#      - Updates README.md with the latest compatibility matrix
#      - Commits and pushes documentation updates
#
#   4. RELEASE: Automated release management
#      - Creates GitHub releases for both main branch (stable) and feature branches (development)
#      - Handles version tagging based on galaxy.yml version
#      - Uploads collection artifacts to GitHub Packages
#      - Supports release overwriting for development builds
#
#   5. PUBLISH-TO-GALAXY: Publishes collection to Ansible Galaxy (only on main branch)
#      - Downloads the collection artifact from GitHub release
#      - Publishes to Ansible Galaxy using GALAXY_API_KEY
#      - Verifies the publication was successful
#
#   Triggers: Push to any branch (jobs check if only .md files were changed and skip accordingly), weekly scheduled runs on Sundays at 2:00 AM UTC
#
name: CI/CD Pipeline

on:
  push:
  schedule:
    # Run every Sunday at 2:00 AM UTC (weekly)
    - cron: '0 2 * * 0'

jobs:
  changelog:
    # Only run on main branch pushes, not on PRs or other branches
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      has_fragments: ${{ steps.check_fragments.outputs.has_fragments || 'false' }}
      only_markdown: ${{ steps.check_files.outputs.only_markdown }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if only markdown files were changed
        id: check_files
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Get list of changed files
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }}..${{ github.event.after }} 2>/dev/null || git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            if [ -z "$CHANGED_FILES" ]; then
              # Fallback: check all files in the commit
              CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null || echo "")
            fi
            
            if [ -z "$CHANGED_FILES" ]; then
              echo "only_markdown=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  Could not determine changed files, proceeding with changelog check"
            else
              # Check if all changed files are markdown files (including various markdown file patterns)
              NON_MD_FILES=$(echo "$CHANGED_FILES" | grep -vE '\.(md|MD)$|^docs/.*\.(md|MD)$|^README\.(md|MD)$|^CHANGELOG\.(md|MD)$|^CONTRIBUTING\.(md|MD)$' || true)
              if [ -z "$NON_MD_FILES" ]; then
                echo "only_markdown=true" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è  Only markdown files were changed, skipping changelog generation"
              else
                echo "only_markdown=false" >> $GITHUB_OUTPUT
                echo "‚úÖ Non-markdown files were changed, proceeding with changelog check"
              fi
            fi
          else
            # For scheduled runs, always proceed (don't skip)
            echo "only_markdown=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install antsibull-changelog
        run: |
          python -m pip install --upgrade pip
          pip install antsibull-changelog pyyaml

      - name: Get version from galaxy.yml
        id: get_version
        run: |
          VERSION=$(python -c "import yaml; print(yaml.safe_load(open('galaxy.yml'))['version'])")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Using version: $VERSION"

      - name: Check if fragments exist
        if: steps.check_files.outputs.only_markdown != 'true'
        id: check_fragments
        run: |
          if [ -d "changelogs/fragments" ] && [ -n "$(ls -A changelogs/fragments/*.yml changelogs/fragments/*.yaml 2>/dev/null)" ]; then
            echo "has_fragments=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Found changelog fragments:"
            ls -1 changelogs/fragments/
          else
            echo "has_fragments=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No changelog fragments found."
          fi

      - name: Set default has_fragments if skipped
        if: steps.check_files.outputs.only_markdown == 'true'
        run: |
          echo "has_fragments=false" >> $GITHUB_OUTPUT

      - name: Generate changelog
        if: steps.check_fragments.outputs.has_fragments == 'true'
        run: |
          cd changelogs
          echo "üìù Generating changelog for version ${{ steps.get_version.outputs.version }}..."
          antsibull-changelog release --version ${{ steps.get_version.outputs.version }}
          cd ..

          echo "‚úÖ Changelog generated successfully!"
          ls -la CHANGELOG.rst changelogs/changelog.yaml

      - name: Commit and push changelog
        if: steps.check_fragments.outputs.has_fragments == 'true'
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Add generated/updated files
          git add CHANGELOG.rst changelogs/changelog.yaml

          # Remove fragment files (they're now merged into changelog.yaml)
          if [ -d "changelogs/fragments" ] && [ -n "$(ls -A changelogs/fragments/*.yml changelogs/fragments/*.yaml 2>/dev/null)" ]; then
            git rm changelogs/fragments/*.yml changelogs/fragments/*.yaml 2>/dev/null || true
          fi

          # Commit and push
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            git commit -m "chore: Generate changelog for version ${{ steps.get_version.outputs.version }}"
            git push
            echo "‚úÖ Changelog committed and pushed!"
            echo "‚ö†Ô∏è  This will trigger a new CI/CD run with the updated changelog."
          fi

      - name: Summary
        run: |
          if [ "${{ steps.check_files.outputs.only_markdown }}" == "true" ]; then
            echo "‚ÑπÔ∏è  Only markdown files were changed - skipped changelog generation"
          elif [ "${{ steps.check_fragments.outputs.has_fragments }}" == "true" ]; then
            echo "‚úÖ Changelog generation completed for version ${{ steps.get_version.outputs.version }}"
          else
            echo "‚ÑπÔ∏è  No changelog fragments found - skipped generation"
          fi

  test:
    # Wait for changelog job if it ran, otherwise run immediately
    if: always()
    needs: [changelog]
    runs-on: ubuntu-latest
    outputs:
      only_markdown: ${{ steps.check_files.outputs.only_markdown }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Remember to update sanity ignore files in /tests/sanity/ if you add a new version pares to the test matrix!
          # Refer to https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.html for details on Ansible release and python version support.
          - ansible-version: "2.12"
            python-version: "3.8"
          - ansible-version: "2.12"
            python-version: "3.9"
          - ansible-version: "2.13"
            python-version: "3.8"
          - ansible-version: "2.13"
            python-version: "3.9"
          - ansible-version: "2.13"
            python-version: "3.10"
          - ansible-version: "2.14"
            python-version: "3.9"
          - ansible-version: "2.14"
            python-version: "3.10"
          - ansible-version: "2.14"
            python-version: "3.11"
          - ansible-version: "2.15"
            python-version: "3.9"
          - ansible-version: "2.15"
            python-version: "3.10"
          - ansible-version: "2.15"
            python-version: "3.11"
          - ansible-version: "2.16"
            python-version: "3.10"
          - ansible-version: "2.16"
            python-version: "3.11"
          - ansible-version: "2.16"
            python-version: "3.12"
          - ansible-version: "2.17"
            python-version: "3.10"
          - ansible-version: "2.17"
            python-version: "3.11"
          - ansible-version: "2.17"
            python-version: "3.12"
          - ansible-version: "2.18"
            python-version: "3.11"
          - ansible-version: "2.18"
            python-version: "3.12"
          - ansible-version: "2.18"
            python-version: "3.13"
          - ansible-version: "2.19"
            python-version: "3.11"
          - ansible-version: "2.19"
            python-version: "3.12"
          - ansible-version: "2.19"
            python-version: "3.13"
          - ansible-version: "2.20"
            python-version: "3.12"
          - ansible-version: "2.20"
            python-version: "3.13"
          - ansible-version: "2.20"
            python-version: "3.14"

    name: Test ${{ matrix.python-version }} / Ansible ${{ matrix.ansible-version }}
    env:
      HOME: /home/runner
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check if only markdown files were changed
        id: check_files
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Get list of changed files
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }}..${{ github.event.after }} 2>/dev/null || git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            if [ -z "$CHANGED_FILES" ]; then
              # Fallback: check all files in the commit
              CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null || echo "")
            fi
            
            if [ -z "$CHANGED_FILES" ]; then
              echo "only_markdown=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  Could not determine changed files, proceeding with tests"
            else
              # Check if all changed files are markdown files (including various markdown file patterns)
              NON_MD_FILES=$(echo "$CHANGED_FILES" | grep -vE '\.(md|MD)$|^docs/.*\.(md|MD)$|^README\.(md|MD)$|^CHANGELOG\.(md|MD)$|^CONTRIBUTING\.(md|MD)$' || true)
              if [ -z "$NON_MD_FILES" ]; then
                echo "only_markdown=true" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è  Only markdown files were changed, skipping tests"
              else
                echo "only_markdown=false" >> $GITHUB_OUTPUT
                echo "‚úÖ Non-markdown files were changed, proceeding with tests"
              fi
            fi
          else
            # For scheduled runs, always proceed (don't skip)
            echo "only_markdown=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip tests if only markdown files changed
        if: steps.check_files.outputs.only_markdown == 'true'
        run: |
          echo "‚ÑπÔ∏è  Skipping tests - only markdown files were changed"

      - name: Install Python ${{ matrix.python-version }}
        if: steps.check_files.outputs.only_markdown != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Ansible sanity dependencies
        if: steps.check_files.outputs.only_markdown != 'true'
        run: |
          sudo apt update
          sudo apt install -y shellcheck
          python -m pip install --upgrade pip setuptools wheel

      - name: Install Ansible Core ${{ matrix.ansible-version }}
        if: steps.check_files.outputs.only_markdown != 'true'
        run: |
          pip install "ansible-core==${{ matrix.ansible-version }}.*" || echo "unsupported" > unsupported.flag

      - name: Install test requirements
        if: steps.check_files.outputs.only_markdown != 'true'
        run: |
          pip install -r requirements.txt || true
          pip install yamllint flake8

      - name: Build Ansible Collection
        if: steps.check_files.outputs.only_markdown != 'true'
        run: |
          ansible-galaxy collection build

      - name: List built archive
        if: steps.check_files.outputs.only_markdown != 'true'
        run: ls -lh *.tar.gz

      - name: Install Ansible Collection
        if: steps.check_files.outputs.only_markdown != 'true'
        run: |
          ansible-galaxy collection install pcg-alpaca_operator-*.tar.gz --force --collections-path ~/.ansible/collections

      - name: Run ansible-test (sanity only)
        if: steps.check_files.outputs.only_markdown != 'true'
        working-directory: ${{ env.HOME }}/.ansible/collections/ansible_collections/pcg/alpaca_operator
        run: |
          ansible-test sanity --python ${{ matrix.python-version }} --color --docker || echo "failed" > failed.flag

      - name: Write result
        if: always() && steps.check_files.outputs.only_markdown != 'true'
        run: |
          STATUS="failed"
          if [ -f ~/.ansible/collections/ansible_collections/pcg/alpaca_operator/failed.flag ]; then
            STATUS="failed"
          elif [ -f ~/.ansible/collections/ansible_collections/pcg/alpaca_operator/unsupported.flag ]; then
            STATUS="unsupported"
          else
            STATUS="tested"
          fi
          echo "${{ matrix.python-version }};${{ matrix.ansible-version }};${STATUS}" >> results.csv
        shell: bash

      - name: Upload test result
        if: always() && steps.check_files.outputs.only_markdown != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ matrix.python-version }}-${{ matrix.ansible-version }}
          path: results.csv

      - name: Fail if Ansible sanity failed
        if: always() && steps.check_files.outputs.only_markdown != 'true'
        run: |
          if [ -f ~/.ansible/collections/ansible_collections/pcg/alpaca_operator/failed.flag ]; then
            echo "::error file=ansible-test::Sanity tests failed"
            exit 1
          elif [ -f ~/.ansible/collections/ansible_collections/pcg/alpaca_operator/unsupported.flag ]; then
            echo "::error file=ansible-test::Sanity tests failed"
            exit 1
          fi

  summarize:
    if: always() && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [test]
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: results
          continue-on-error: true

      - name: Check if test artifacts exist
        id: check_artifacts
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            # For scheduled runs, always check for artifacts (tests should have run)
            if [ -d "results" ] && [ -n "$(find results -name '*.csv' -type f 2>/dev/null)" ]; then
              echo "artifacts_exist=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Found test artifacts"
            else
              echo "artifacts_exist=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  No test artifacts found - skipping support matrix update"
            fi
          else
            # For push events, check for artifacts
            if [ -d "results" ] && [ -n "$(find results -name '*.csv' -type f 2>/dev/null)" ]; then
              echo "artifacts_exist=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Found test artifacts"
            else
              echo "artifacts_exist=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  No test artifacts found - skipping support matrix update"
            fi
          fi

      - name: Combine CSVs
        if: steps.check_artifacts.outputs.artifacts_exist == 'true'
        run: |
          cat results/**/*.csv > combined.csv

      - name: Install Python dependencies
        if: steps.check_artifacts.outputs.artifacts_exist == 'true'
        run: pip install pandas

      - name: Generate support matrix
        if: steps.check_artifacts.outputs.artifacts_exist == 'true'
        run: |
          python3 .github/scripts/generate-support-matrix.py combined.csv > support_matrix.md

      - name: Upload support matrix
        if: always() && steps.check_artifacts.outputs.artifacts_exist == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: support-matrix
          path: support_matrix.md

      - name: Update README.md with latest support matrix
        if: steps.check_artifacts.outputs.artifacts_exist == 'true'
        run: |
          python3 .github/scripts/update-readme.py

      - name: Commit updated README.md
        if: steps.check_artifacts.outputs.artifacts_exist == 'true'
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Pull latest changes before checking (in case changelog was committed)
          echo "üì• Pulling latest changes from remote..."
          git fetch origin main
          git reset --hard origin/main

          # Check if there are changes before staging
          if git diff --quiet README.md; then
            echo "‚ÑπÔ∏è  No changes to commit - README.md is already up to date"
            exit 0
          fi

          # Stage the README.md changes
          git add README.md

          echo "üíæ Committing README.md update..."
          git commit -m "Update support matrix [ci skip]"

          echo "üì§ Pushing changes..."
          git push origin main

          echo "‚úÖ README.md successfully updated and pushed!"

  release:
    if: (needs.summarize.result == 'success' || needs.summarize.result == 'skipped') && (needs.test.result == 'success' || needs.test.result == 'skipped')
    runs-on: ubuntu-latest
    needs: [test, summarize]
    permissions:
      contents: write
      packages: write
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -r requirements.txt || true
          pip install PyYAML

      - name: Build Ansible Collection
        run: |
          ansible-galaxy collection build

      - name: Get version and branch info
        id: version
        run: |
          VERSION=$(python -c "import yaml; print(yaml.safe_load(open('galaxy.yml'))['version'])")
          BRANCH_NAME=${GITHUB_REF#refs/heads/}

          if [ "$BRANCH_NAME" = "main" ]; then
            TAG="v$VERSION"
            RELEASE_TITLE="Release $TAG"
            RELEASE_NOTES="Ansible Collection Release for pcg.alpaca_operator version $VERSION"
          else
            # Sanitize branch name for use in tag (replace special chars with hyphens)
            SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9]/-/g')
            TAG="dev-$SANITIZED_BRANCH-v$VERSION"
            RELEASE_TITLE="$TAG"
            RELEASE_NOTES="Development release of pcg.alpaca_operator version $VERSION from branch $BRANCH_NAME"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "release_title=$RELEASE_TITLE" >> $GITHUB_OUTPUT
          echo "release_notes=$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Check if release already exists
        id: check_release
        run: |
          if gh release view ${{ steps.version.outputs.tag }} 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Delete existing release if it exists
        if: steps.check_release.outputs.exists == 'true'
        run: |
          echo "Release ${{ steps.version.outputs.tag }} already exists, deleting it to overwrite"
          gh release delete ${{ steps.version.outputs.tag }} --yes

      - name: Create or Recreate Release
        run: |
          gh release create ${{ steps.version.outputs.tag }} \
            --title "${{ steps.version.outputs.release_title }}" \
            --notes "${{ steps.version.outputs.release_notes }}" \
            pcg-alpaca_operator-${{ steps.version.outputs.version }}.tar.gz

      - name: Upload collection to GitHub Packages
        run: |
          gh release upload ${{ steps.version.outputs.tag }} pcg-alpaca_operator-${{ steps.version.outputs.version }}.tar.gz --clobber

  publish-to-galaxy:
    # Only publish to Galaxy for stable releases on main branch
    if: needs.release.result == 'success' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [release]
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install ansible-core PyYAML

      - name: Get latest release info
        id: release
        run: |
          # Get the latest release tag
          LATEST_TAG=$(git describe --tags --abbrev=0)
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # Extract version from tag (remove 'v' prefix if present)
          VERSION=${LATEST_TAG#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          echo "üì¶ Publishing version: $VERSION (tag: $LATEST_TAG)"

      - name: Download collection artifact from release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üì• Downloading collection artifact from GitHub release..."
          gh release download ${{ steps.release.outputs.tag }} --pattern "pcg-alpaca_operator-*.tar.gz"

          # Verify the artifact was downloaded
          ls -la pcg-alpaca_operator-*.tar.gz
          echo "‚úÖ Artifact downloaded successfully"

      - name: Publish to Ansible Galaxy
        run: |
          echo "üöÄ Publishing to Ansible Galaxy..."
          ansible-galaxy collection publish pcg-alpaca_operator-${{ steps.release.outputs.version }}.tar.gz --token ${{ secrets.GALAXY_API_KEY }}

          echo "‚úÖ Successfully published pcg.alpaca_operator version ${{ steps.release.outputs.version }} to Ansible Galaxy"

      - name: Verify publication
        run: |
          echo "üîç Verifying publication on Ansible Galaxy..."
          # Wait a moment for Galaxy to process the upload
          sleep 10

          # Try to install the collection from Galaxy to verify it was published
          ansible-galaxy collection install pcg.alpaca_operator:${{ steps.release.outputs.version }} --force

          echo "‚úÖ Collection successfully verified on Ansible Galaxy"